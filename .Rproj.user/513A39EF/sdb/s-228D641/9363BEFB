{
    "contents" : "#' Prediction for Beta-Binomial regression.\n#'\n#' @param fit A fitted geem_betabinomial object.\n#' @param M A vector of total cell counts.\n#' @param X An optional matrix of explanatory variables.\n#'\n#' @return Returns a vector of expected counts\n#'\npredictBB <- function(fit,N,X=NULL) {\n  eta <- predict(fit)\n  expectation <- N*exp(eta)/(1+exp(eta))\n  return(expectation)\n}\n\n#' Fit a beta-binomial generalized estimating equation model.\n#'\n#' Calculate coefficients and nuisance parameters for the beta-binomial\n#' model using generalized estimating equations. Implementation is based\n#' on the geeM package.\n#'\n#' @param formula See corresponding documentation to \\code{geem}.\n#' @param N A vector of total counts of length \\code{reponse}.\n#' @param id See corresponding documentation to \\code{geem}.\n#' @param data See corresponding documentation to \\code{geem}.\n#' @param corstr See corresponding documentation to \\code{geem}.\n#' @param Mv See corresponding documentation to \\code{geem}.\n#' @param weights See corresponding documentation to \\code{geem}.\n#' @param corr.mat See corresponding documentation to \\code{geem}.\n#' @param init.beta See corresponding documentation to \\code{geem}.\n#' @param init.alpha See corresponding documentation to \\code{geem}.\n#' @param init.phi See corresponding documentation to \\code{geem}.\n#' @param scale.fix See corresponding documentation to \\code{geem}.\n#' @param nodummy See corresponding documentation to \\code{geem}.\n#' @param sandwich See corresponding documentation to \\code{geem}.\n#' @param maxit See corresponding documentation to \\code{geem}.\n#' @param tol See corresponding documentation to \\code{geem}.\n#'\n#'\n#' @return An object of class \"geem_betabinomial\ngeem_betabinomial <- function(formula,N,id,waves,data=parent.frame(),\n                              corstr=\"independence\",weights=NULL,corr.mat=NULL,\n                              init.beta=NULL,init.alpha=NULL,init.phi=1,init.rho=0,\n                              rho.fixed=FALSE,\n                              scale.fix=FALSE,nodummy=FALSE,sandwich=TRUE,\n                              maxit=20,tol=1e-05) {\n\n  #Family functions\n  LinkFun <- function(mu) {\n    p <- mu/N\n    log(p/(1-p))\n  }\n\n  InvLink <- function(eta) {\n    N/(1+exp(-eta))\n  }\n\n  InvLinkDeriv <- function(eta) {\n    N*exp(-eta)/(1+exp(-eta))^2\n  }\n\n  VarFun <- function(mu) {\n    p <- mu/N\n    N*p*(1-p)*(1+(N-1)*rho)\n  }\n\n  #Preparing call\n  call <- as.list(match.call())\n  call <- call[-1]\n  rho <- init.rho\n  rhos <- rho\n  FunList <- list(LinkFun=LinkFun,VarFun=VarFun,InvLink=InvLink,InvLinkDeriv=InvLinkDeriv)\n\n  #getting N\n  if(typeof(data) == \"environment\"){\n    N <- N\n  } else {\n    if(length(call$N) == 1){\n      N.col <- which(colnames(data) == call$N)\n      if(length(N.col) > 0) {\n        N <- data[,N.col]\n      } else {\n        N <- eval(call$N, envir=parent.frame())\n      }\n    }else if(is.null(call$N)){\n      stop(\"N must be specified!\")\n    }\n  }\n\n  varArgs <- list(N=N,rho=rho)\n  call$family <- FunList\n\n  #initializing beta with geeglm\n  require(geepack)\n  env <- parent.frame()\n  modelMatCall <- list(object=call$formula,data=call$data)\n  modelMat <- do.call(\"model.matrix\",modelMatCall,envir=env)\n  solve(t(modelMat)%*%modelMat)\n\n  modelFrameCall <- list(formula=formula,data=data)\n  response <- model.response(do.call(\"model.frame\",modelFrameCall))\n\n  callGeeglm <- call\n  callGeeglm$family <- \"binomial\"\n  callGeeglm$formula <- cbind(response,N-response) ~ modelMat-1\n  if(any(names(callGeeglm)==\"rho.fixed\")) {\n    callGeeglm <- callGeeglm[-which(names(callGeeglm)==\"rho.fixed\")]\n  }\n  callGeeglm <- callGeeglm[-which(names(callGeeglm)==\"N\")]\n  fit <- do.call(\"geeglm\",callGeeglm,envir=env)\n\n  betas <- matrix(coef(fit),ncol=1)\n\n  for(i in 2:10) {\n    #If rho doesn't need to be update then break\n    if(rho.fixed==TRUE & i > 2) {\n      break\n    }\n\n    rhoOld <- rho\n    #update rho\n    if(rho.fixed==FALSE) {\n      yhat <- predictBB(fit,N)\n      residuals <- get((all.vars(formula)[1]),data) - yhat\n\n      rho <- lm(residuals^2~ offset(yhat*(1-yhat/N)) + I(yhat*(1-yhat/N)*(N-1)))$coefficients[2]\n      if(rho < 0 | rho >=1) {\n        warning(\"estimate rho not in [0,1)\")\n        rho <- min(max(rho,0),.9995)\n        if(rho==0) break\n      }\n      rhos <- c(rhos,rho)\n    }\n\n    call$init.beta <- as.vector(betas[,i-1])\n    try(fit <- do.call(\"geem\",call,envir=env))\n    betas <- cbind(betas,coef(fit))\n\n    varArgs$rho <- rho\n    if(abs(rhoOld-rho)<10^-6 | rho==0) break\n  }\n\n  fit$rhos <- as.vector(rhos)\n  betas <- data.frame(betas)\n  names(betas) <- paste(\"rho\",round(rhos,4),sep=\"\")\n  fit$betaMat <- betas\n  return(fit)\n}\n",
    "created" : 1453228197227.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3891000207",
    "id" : "9363BEFB",
    "lastKnownWriteTime" : 1453228758,
    "path" : "~/Documents/rglab/geeod/R/betaBinomialReg.R",
    "project_path" : "R/betaBinomialReg.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}